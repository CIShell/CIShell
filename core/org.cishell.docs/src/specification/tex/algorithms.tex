\section{Algorithm Specification}

\subsection*{\textit{Version 1.0}}

\subsection{Introduction}

The CIShell Platform has been specifically designed around the idea of the
algorithm. It is the central and most important concept. Algorithms are fully
defined and self-contained bits of execution. They can do many things from data
conversion, data analysis, and can even spawn whole outside programs if it needs
to. Algorithms are very well defined black boxes in that what can come into and
out of the algorithm is specified in each algorithm's metadata. Other than that,
CIShell makes no attempt to understand the algorithm.

To be recognized by CIShell, an \class{AlgorithmFactory} must be registered with
OSGi's Service Registry. The service registry requires three things when
registering: an interface (\class{AlgorithmFactory}), an implementation, and a
\class{Dictionary} of metadata. The algorithm developer provides the
implementation and metadata. The metadata helps to differentiate and define the
algorithm for search and discovery, see section \ref{algMetaData}.

An algorithm defines its inputs in two ways. First, the input data is defined in
the algorithm's service metadata. Second, the acceptable user-entered parameters
are defined in a \class{MetaTypeProvider}, see section \ref{GUISpec}.

Figure \ref{fig:algExecWorkflow} shows the typical flow of information into and
out of an algorithm. First the input parameter specification is pulled from the
\class{AlgorithmFactory}. If parameters are needed, then a UI is created and user
inputs are entered. To create an \class{Algorithm}, the \class{AlgorithmFactory}
is passed the user-entered parameters, zero or more pieces of data, and a
\class{CIShellContext}. The \class{Algorithm} is then executed and produces zero
or more pieces of data.

\begin{figure}[htb!]
\centering
\includegraphics[width=150mm]{../img/algExecWorkflow.pdf}
\caption{Algorithm Execution Workflow}
\label{fig:algExecWorkflow}
\end{figure}

\subsection{Optional Interfaces}

Algorithm developers may augment algorithms with additional interfaces to enhance
parts of the execution workflow. An \class{AlgorithmFactory} can also implement
the \class{DataValidator} interface to validate the data beyond the data format
validation that an application should provide ahead of time. An \class{Algorithm}
can implement \class{ProgressTrackable} to allow for more detailed monitoring and
control of an \class{Algorithm}'s progress while executing. See each interface's
documentation for more details.

\subsection{Algorithm Service Metadata Definition}
\label{algMetaData}

When an algorithm is registered with OSGi's service registry, a dictionary of
metadata is provided. Since the algorithm itself is a black box, the metadata is
used to provide information about the algorithm. Information such as the format
of each \class{Data} item to be inputted and outputted is provided. In addition
to the mechanics of the algorithms, interesting data such as the authors, label,
urls, and description are provided. This metadata can be searched by anyone using
OSGi's service registry to find relevant algorithms for use.

Each standard metadata element required by the CIShell specification is defined
below and in the interface \class{AlgorithmProperty}. It defines each key string
and the valid value strings to set in the metadata \class{Dictionary} when
registering an algorithm as a service.

\subsection*{service.pid}
A string that uniquely identifies the algorithm. The service.pid should not
change between sessions and only one algorithm with a given service.pid should
be available in the service registry at any given time. It is recommended to 
use the Java naming scheme including path for this purpose, i.e.
``org.cishell.my.algorithm.MyAlgorithm''. This metadata element is defined
as part of the OSGi Service Platform Core Specification, section 6.1.12.58. 

\subsection*{in\_data}
Specifies the type and number of \class{Data} inputs the
algorithm accepts. The string is a comma separated list of data formats. Valid strings
for each data format are: a full Java class if a Java \class{Object} is
expected, a string with the format ``file:\textit{mime/type}'' if a
\class{java.io.File} is expected, or a string with the format
``file-ext:\textit{file-extension}'' if a \class{java.io.File} known only by
extension is expected (only applicable for validator algorithms), see section
\ref{dataSpec}. If no \class{Data} inputs are necessary then the string
``null'' or not specifying the in\_data attribute at all is valid.

\subsection*{out\_data}
Specifies the type and number of \class{Data} outputs
the algorithm will produce when successfully run. This metadata key has the same string format
as defined in the in\_data specification. If no \class{Data} outputs are
produced then the string ``null'' or not specifying the out\_data attribute at
all is valid.

\subsection*{parentage}
If this metadata element is used, it defines how the output \class{Data}
produced by the algorithm should be arranged. \class{Data} items can be given a parent as
part of their metadata (which qsually means the \class{Data} was derived from the
referenced \class{Data}). If parentage is set to ``default'' then each of the
algorithm's outputted \class{Data} items will have their parent \class{Data} item
set as the first inputted \class{Data} item (if applicable) by the
CIShell-conforming application. If parentage is set to something else or is not
set at all, then it is up to the algorithm to set up these relationships.

\subsection*{type}
Specifies the type of the algorithm. If no type is set, then
it is assumed to be of ``Standard Algorithm'' type. Which metadata keys to use and
their exact meaning varies depending on the type of algorithm. The different
algorithm types and their constraints are defined in section
\ref{algConstraints}.

\subsection*{remotable}
Specifies if the algorithm can be run remotely. An algorithm can be run
remotely if it only uses the services provided by the \class{CIShellContext}
and does not create its own non-\class{GUIBuilderService}-built GUI. Valid
strings are ``true'' or ``false''. If this metadata element is not set, then
it is assumed that it cannot be run remotely.

\subsection*{label}
Specifies a human-readable short name for the algorithm. What label is
acceptable varies depending on the type of the algorithm. 

\subsection*{description}
Provides more details on the workings of the algorithm. What
description is acceptable varies depending on the type of the algorithm.

\subsection*{menu\_path}
Specifies where on the menu an algorithm is to be
placed if a menu bar is used. Otherwise, it can act as a primitive hierarchical
classification of the algorithm. The string is a ``/'' separated list with
each element in the list getting more specific. The last element in the list
specifies a group for grouping algorithms in its final menu. Possible groups
include: ``additions'' for default placement, ``start'' for being placed at
the start of the menu, or ``end'' for being placed at the end of the menu. Some
examples of valid menu\_path strings include: ``File/additions'',
``Analysis/Undirected Networks/start'', and ``Visualization/Networks/end''.

\subsection*{conversion}
For converter algorithms, this metadata element specifies if any data is
lossed in the conversion. Possible values are ``lossy'' and ``lossless''. A
description of what type of information is lost should be explained in the
description.

\subsection*{authors}
A comma separated list of the authors of the abstract algorithm.

\subsection*{implementers}
A comma separated list of the developers who implemented the algorithm in code.

\subsection*{integrators}
A comma separated list of the developers who integrated the algorithm code as
a compliant cishell algorithm.

\subsection*{documentation\_url}
A URL to relevant documentation for the algorithm.

\subsection*{reference}
A formal reference to a paper explaining the abstract algorithm.

\subsection*{reference\_url}
A URL to a paper explaining the abstract algorithm.

\subsection*{written\_in}
A comma separated list of the programming languages used to implement and
integrate the algorithm code.
